# -*- coding: utf-8 -*-
"""FRAS 's Demo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H0eYQILo6Kzs8P1bAfQZPK8AgMNEW3g7

# **Libraries**
"""

!pip install keras_facenet
!pip install mtcnn
import numpy as np
import cv2
from PIL import Image
from matplotlib.patches import Rectangle
import matplotlib.pyplot as plt
from keras_facenet import FaceNet
from mtcnn import MTCNN
import pickle
import pandas as pd
from google.colab import files
from sklearn.preprocessing import LabelEncoder
import datetime

"""# **Loading Saved Models**"""

# Initializing FaceNet
embedder = FaceNet()

# Loading the face embeddings and labels
embeddings_data = np.load('/content/faces_embeddings_done_6classes.npz')
stored_embeddings = embeddings_data['arr_0']  # Embeddings of known faces
stored_labels = embeddings_data['arr_1']  # Corresponding labels of known faces

# Load the pre-trained SVM model
with open('/content/svcFRASSSSSS_model.pkl', 'rb') as f:
    model = pickle.load(f)

# Load the students dataset
students_dataset_path = '/content/StudentsDatasetIDs.xlsx'
students_data = pd.read_excel(students_dataset_path)

"""Defining Functions"""

def detect_faces(image_path):
    img = cv2.imread(image_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    detector = MTCNN()
    results = detector.detect_faces(img)
    return results

def crop_faces(image_path, results, required_size=(160, 160)):
    image = Image.open(image_path).convert('RGB')
    pixels = np.asarray(image)
    faces = []

    for result in results:
        x, y, width, height = result['box']
        x, y = abs(x), abs(y)  # Set coordinates to positive
        x2, y2 = x + width, y + height
        face = pixels[y:y2, x:x2]
        face_image = Image.fromarray(face).resize(required_size)
        faces.append(np.asarray(face_image))

    return np.array(faces)


def get_face_embeddings(embedder, faces):
    embeddings = []
    for face in faces:
        face = face.astype('float32')
        face = np.expand_dims(face, axis=0)
        yhat = embedder.embeddings(face)
        embeddings.append(yhat[0])
    return np.array(embeddings)

# Enter Course Name / ID
course_name = input("Please enter the course name: ")

# Date
current_date = datetime.date.today().strftime("%Y-%m-%d")

uploaded = files.upload()


uploaded_image = list(uploaded.keys())[0]  # Get the file name
image_path = uploaded_image

# Detect faces in the uploaded image
results = detect_faces(image_path)
if not results:
    print(f"No faces detected in {image_path}")
else:
    cropped_faces = crop_faces(image_path, results)
    face_embeddings = get_face_embeddings(embedder, cropped_faces)

    # Predict the identities of the detected faces using the SVM model
    predicted_labels = model.predict(face_embeddings)

    # Get the predicted names based on predicted labels
    encoder = LabelEncoder()
    encoder.fit(stored_labels)  # Fit the encoder on the known labels
    predicted_names = encoder.inverse_transform(predicted_labels)


    predicted_full_names = []
    predicted_ids = []

    for name in predicted_names:
        # Find the row where the name matches
        matching_row = students_data[students_data['Label'] == name]

        if not matching_row.empty:
            # Get the full name and ID from the matching row
            full_name = matching_row.iloc[0]['Name']
            student_id = matching_row.iloc[0]['ID']
        else:
            # If no match is found, Set to 'Unknown'
            full_name = 'Unknown'
            student_id = 'Unknown'

        predicted_full_names.append(full_name)
        predicted_ids.append(student_id)


    print("Predicted Names:", predicted_full_names)
    print("Predicted IDs:", predicted_ids)


    image = Image.open(image_path).convert('RGB')
    plt.figure(figsize=(10, 10))
    plt.imshow(image)
    ax = plt.gca()

    for result, name, student_id in zip(results, predicted_full_names, predicted_ids):
        x, y, width, height = result['box']
        rect = Rectangle((x, y), width, height, fill=False, color='red', linewidth=2)
        ax.add_patch(rect)
        plt.text(x, y - 10, f'{name} ({student_id})', color='red', fontsize=12, backgroundcolor='white')

    plt.axis('off')
    plt.show()

    attendance = {"Name": predicted_full_names, "ID": predicted_ids, "Date": [current_date] * len(predicted_full_names), "Status": ["Present"] * len(predicted_full_names)}

    # Save the attendance to an Excel file named by course and date
    output_path = f"/content/{course_name}_{current_date}_attendance.xlsx"
    df = pd.DataFrame(attendance)
    df.to_excel(output_path, index=False)

    print(f"Attendance sheet created: {output_path}")
    files.download(output_path)  # Download the generated Excel file